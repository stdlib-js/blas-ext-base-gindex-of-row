{"version":3,"file":"index.mjs","sources":["../lib/base.js","../lib/accessors.js","../lib/main.js","../lib/ndarray.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major';\nimport arraylike2object from '@stdlib/array-base-arraylike2object';\nimport ones from '@stdlib/array-base-ones';\nimport accessors from './accessors.js';\n\n\n// MAIN //\n\n/**\n* Returns the index of the first row in an input matrix which has the same elements as a provided search vector.\n*\n* ## Notes\n*\n* -   If the function is provided an empty matrix or if the function is unable to find a search vector, the function returns `-1` (i.e., an invalid index).\n*\n* @private\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Collection} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {Collection} x - search vector\n* @param {integer} strideX - stride length for `x`\n* @param {NonNegativeInteger} offsetX - index offset for `x`\n* @returns {integer} row index\n*\n* @example\n* var A = [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 3.0, 4.0 ];\n*\n* var out = gindexOfRow( 3, 2, A, 2, 1, 0, x, 1, 0 );\n* // returns 1\n*\n* @example\n* var A = [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 3.0, 4.0 ];\n*\n* var out = gindexOfRow( 3, 2, A, 1, 3, 0, x, 1, 0 );\n* // returns 1\n*\n* @example\n* var A = [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 1.0, 2.0 ];\n*\n* var out = gindexOfRow( 3, 2, A, 1, 3, 0, x, 1, 0 );\n* // returns 0\n*\n* @example\n* var A = [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 0.0, 0.0 ];\n*\n* var out = gindexOfRow( 3, 2, A, 1, 3, 0, x, 1, 0 );\n* // returns 2\n*\n* @example\n* var A = [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ -3.0, -4.0 ];\n*\n* var out = gindexOfRow( 3, 2, A, 1, 3, 0, x, 1, 0 );\n* // returns -1\n*/\nfunction gindexOfRow( M, N, A, strideA1, strideA2, offsetA, x, strideX, offsetX ) { // eslint-disable-line max-len\n\tvar matches;\n\tvar da0;\n\tvar da1;\n\tvar S0;\n\tvar S1;\n\tvar ia;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar oa;\n\tvar ox;\n\n\t// Check whether the matrix is an empty matrix...\n\tif ( M <= 0 || N <= 0 ) {\n\t\treturn -1;\n\t}\n\toa = arraylike2object( A );\n\tox = arraylike2object( x );\n\tif ( oa.accessorProtocol || ox.accessorProtocol ) {\n\t\treturn accessors( M, N, oa, strideA1, strideA2, offsetA, ox, strideX, offsetX ); // eslint-disable-line max-len\n\t}\n\t// Search for the first row matching the search vector...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tS0 = N;\n\t\tS1 = M;\n\n\t\t// Scan a row-major linear buffer from the first indexed element to the last indexed element, always moving in the same direction when both strides are the same sign, thus ensuring cache optimal traversal...\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tia = offsetA + ( i1*strideA1 );\n\t\t\tix = offsetX;\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tif ( A[ ia ] !== x[ ix ] ) {\n\t\t\t\t\t// We found an element which is not in the search vector...\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tia += strideA2;\n\t\t\t\tix += strideX;\n\t\t\t}\n\t\t\t// If we successfully iterated over all columns, then that means we've found a match...\n\t\t\tif ( i0 === S0 ) {\n\t\t\t\treturn i1;\n\t\t\t}\n\t\t}\n\t\t// If we've made it here, then no rows match the search vector:\n\t\treturn -1;\n\t}\n\t// Column-major...\n\tS0 = M;\n\tS1 = N;\n\n\t// Resolve loop offset (pointer) increments:\n\tda0 = strideA1;\n\tda1 = strideA2 - ( S0*strideA1 );\n\n\t// Create an array for tracking which rows contain matching elements:\n\tmatches = ones( M );\n\n\t// Finding the first matching row when a matrix is stored in column-major order requires effectively performing a full linear scan. In order to ensure cache-efficient traversal, scan down each column (otherwise, if we went row-by-row, we'd hop around linear memory, resulting in poor cache behavior)...\n\tia = offsetA;\n\tix = offsetX;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t// Scan down the rows in a column looking for a matching element...\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tif ( A[ ia ] !== x[ ix ] ) {\n\t\t\t\t// We found a non-matching element, which means we can exclude this row from the list of row candidates...\n\t\t\t\tmatches[ i0 ] = 0;\n\t\t\t}\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t\tix += strideX;\n\t}\n\t// Search for the first matching row...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tif ( matches[ i0 ] === 1 ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ( i0 === S0 ) ? -1 : i0;\n}\n\n\n// EXPORTS //\n\nexport default gindexOfRow;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major';\nimport ones from '@stdlib/array-base-ones';\n\n\n// MAIN //\n\n/**\n* Returns the index of the first row in an input matrix which has the same elements as a provided search vector.\n*\n* ## Notes\n*\n* -   If the function is unable to find a search vector, the function returns `-1` (i.e., an invalid index).\n*\n* @private\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Object} A - input matrix object\n* @param {Collection} A.data - input matrix data\n* @param {Array<Function>} A.accessors - matrix element accessors\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {Object} x - search vector object\n* @param {Collection} x.data - search vector data\n* @param {Array<Function>} x.accessors - search vector element accessors\n* @param {integer} strideX - stride length for `x`\n* @param {NonNegativeInteger} offsetX - index offset for `x`\n* @returns {integer} row index\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import arraylike2object from '@stdlib/array-base-arraylike2object';\n*\n* var A = [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 3.0, 4.0 ];\n*\n* var out = gindexOfRow( 3, 2, arraylike2object( toAccessorArray( A ) ), 2, 1, 0, arraylike2object( toAccessorArray( x ) ), 1, 0 );\n* // returns 1\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import arraylike2object from '@stdlib/array-base-arraylike2object';\n*\n* var A = [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 3.0, 4.0 ];\n*\n* var out = gindexOfRow( 3, 2, arraylike2object( toAccessorArray( A ) ), 1, 3, 0, arraylike2object( toAccessorArray( x ) ), 1, 0 );\n* // returns 1\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import arraylike2object from '@stdlib/array-base-arraylike2object';\n*\n* var A = [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 1.0, 2.0 ];\n*\n* var out = gindexOfRow( 3, 2, arraylike2object( toAccessorArray( A ) ), 1, 3, 0, arraylike2object( toAccessorArray( x ) ), 1, 0 );\n* // returns 0\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import arraylike2object from '@stdlib/array-base-arraylike2object';\n*\n* var A = [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 0.0, 0.0 ];\n*\n* var out = gindexOfRow( 3, 2, arraylike2object( toAccessorArray( A ) ), 1, 3, 0, arraylike2object( toAccessorArray( x ) ), 1, 0 );\n* // returns 2\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n* import arraylike2object from '@stdlib/array-base-arraylike2object';\n*\n* var A = [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ -3.0, -4.0 ];\n*\n* var out = gindexOfRow( 3, 2, arraylike2object( toAccessorArray( A ) ), 1, 3, 0, arraylike2object( toAccessorArray( x ) ), 1, 0 );\n* // returns -1\n*/\nfunction gindexOfRow( M, N, A, strideA1, strideA2, offsetA, x, strideX, offsetX ) { // eslint-disable-line max-len\n\tvar matches;\n\tvar abuf;\n\tvar xbuf;\n\tvar aget;\n\tvar xget;\n\tvar da0;\n\tvar da1;\n\tvar S0;\n\tvar S1;\n\tvar ia;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\n\t// Cache references to array data:\n\tabuf = A.data;\n\txbuf = x.data;\n\n\t// Cache references to the element accessors:\n\taget = A.accessors[ 0 ];\n\txget = x.accessors[ 0 ];\n\n\t// Search for the first row matching the search vector...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tS0 = N;\n\t\tS1 = M;\n\n\t\t// Scan a row-major linear buffer from the first indexed element to the last indexed element, always moving in the same direction when both strides are the same sign, thus ensuring cache optimal traversal...\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tia = offsetA + ( i1*strideA1 );\n\t\t\tix = offsetX;\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tif ( aget( abuf, ia ) !== xget( xbuf, ix ) ) {\n\t\t\t\t\t// We found an element which is not in the search vector...\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tia += strideA2;\n\t\t\t\tix += strideX;\n\t\t\t}\n\t\t\t// If we successfully iterated over all columns, then that means we've found a match...\n\t\t\tif ( i0 === S0 ) {\n\t\t\t\treturn i1;\n\t\t\t}\n\t\t}\n\t\t// If we've made it here, then no rows match the search vector:\n\t\treturn -1;\n\t}\n\t// Column-major...\n\tS0 = M;\n\tS1 = N;\n\n\t// Resolve loop offset (pointer) increments:\n\tda0 = strideA1;\n\tda1 = strideA2 - ( S0*strideA1 );\n\n\t// Create an array for tracking which rows contain matching elements:\n\tmatches = ones( M );\n\n\t// Finding the first matching row when a matrix is stored in column-major order requires effectively performing a full linear scan. In order to ensure cache-efficient traversal, scan down each column (otherwise, if we went row-by-row, we'd hop around linear memory, resulting in poor cache behavior)...\n\tia = offsetA;\n\tix = offsetX;\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t// Scan down the rows in a column looking for a matching element...\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tif ( aget( abuf, ia ) !== xget( xbuf, ix ) ) {\n\t\t\t\t// We found a non-matching element, which means we can exclude this row from the list of row candidates...\n\t\t\t\tmatches[ i0 ] = 0;\n\t\t\t}\n\t\t\tia += da0;\n\t\t}\n\t\tia += da1;\n\t\tix += strideX;\n\t}\n\t// Search for the first matching row...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tif ( matches[ i0 ] === 1 ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ( i0 === S0 ) ? -1 : i0;\n}\n\n\n// EXPORTS //\n\nexport default gindexOfRow;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas-base-assert-is-layout';\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray-base-assert-is-column-major-string';\nimport stride2offset from '@stdlib/strided-base-stride2offset';\nimport max from '@stdlib/math-base-special-fast-max';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns the index of the first row in an input matrix which has the same elements as a provided search vector.\n*\n* ## Notes\n*\n* -   If the function is provided an empty matrix or if the function is unable to find a search vector, the function returns `-1` (i.e., an invalid index).\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Collection} A - input matrix\n* @param {integer} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {Collection} x - search vector\n* @param {integer} strideX - stride length for `x`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fifth argument must be greater than or equal to max(1,N)\n* @returns {integer} row index\n*\n* @example\n* var A = [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 3.0, 4.0 ];\n*\n* var out = gindexOfRow( 'row-major', 3, 2, A, 2, x, 1 );\n* // returns 1\n*/\nfunction gindexOfRow( order, M, N, A, LDA, x, strideX ) {\n\tvar sa1;\n\tvar sa2;\n\tvar s;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) ) {\n\t\ts = N;\n\t} else {\n\t\ts = M;\n\t}\n\tif ( LDA < max( 1, s ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be greater than or equal to max(1,%d). Value: `%d`.', s, LDA ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( M, N, A, sa1, sa2, 0, x, strideX, stride2offset( N, strideX ) ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default gindexOfRow;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns the index of the first row in an input matrix which has the same elements as a provided search vector using alternative indexing semantics.\n*\n* ## Notes\n*\n* -   If the function is provided an empty matrix or if the function is unable to find a search vector, the function returns `-1` (i.e., an invalid index).\n*\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Collection} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {Collection} x - search vector\n* @param {integer} strideX - stride length for `x`\n* @param {NonNegativeInteger} offsetX - index offset for `x`\n* @returns {integer} row index\n*\n* @example\n* var A = [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 3.0, 4.0 ];\n*\n* var out = gindexOfRow( 3, 2, A, 2, 1, 0, x, 1, 0 );\n* // returns 1\n*/\nfunction gindexOfRow( M, N, A, strideA1, strideA2, offsetA, x, strideX, offsetX ) { // eslint-disable-line max-len\n\treturn base( M, N, A, strideA1, strideA2, offsetA, x, strideX, offsetX );\n}\n\n\n// EXPORTS //\n\nexport default gindexOfRow;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Return the index of the first row in an input matrix which has the same elements as a provided search vector.\n*\n* @module @stdlib/blas-ext-base-gindex-of-row\n*\n* @example\n* import gindexOfRow from '@stdlib/blas-ext-base-gindex-of-row';\n*\n* var A = [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ]; // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n* var x = [ 3.0, 4.0 ];\n*\n* var out = gindexOfRow( 'row-major', 3, 2, A, 2, x, 1 );\n* // returns 1\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default main;\n"],"names":["gindexOfRow","M","N","A","strideA1","strideA2","offsetA","x","strideX","offsetX","matches","da0","da1","S0","S1","ia","ix","i0","i1","oa","ox","arraylike2object","accessorProtocol","abuf","xbuf","aget","xget","data","accessors","isRowMajor","ones","order","LDA","sa1","sa2","s","isLayout","TypeError","format","max","RangeError","isColumnMajor","base","stride2offset","setReadOnly","main","ndarray"],"mappings":"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"}